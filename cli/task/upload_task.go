// Copyright (c) 2022 by Reiform. All Rights Reserved.

package task

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"reiform.com/mynah-cli/server"
	"reiform.com/mynah-cli/utils"
	"reiform.com/mynah/log"
	"reiform.com/mynah/model"
)

// UploadedFilesSet maps from fileid to the local file path
type UploadedFilesSet map[model.MynahUuid]string

const maxUploadWorkers = 10

// MynahUploadTask defines the task of uploading files to the server from some source
type MynahUploadTask struct {
	//the paths to folders to upload
	FolderPaths []string `json:"folder_paths"`
	//whether to use multiple threads
	Multithread bool `json:"multithread"`
}

//the result of performing an upload request
type uploadResult struct {
	err          error
	fileid       model.MynahUuid
	originalPath string
}

// returns error if this path is not to a folder
func pathMustBeDir(path string) error {
	file, err := os.Open(filepath.Clean(path))
	if err != nil {
		return err
	}

	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			log.Warnf("failed to close file: %s", err)
		}
	}(file)

	//check that this is a folder
	if fileInfo, err := file.Stat(); err != nil {
		return err
	} else if !fileInfo.IsDir() {
		return fmt.Errorf("path %s is not a folder", path)
	}
	return nil
}

// execute uploads
func uploadWorker(mynahServer *server.MynahClient, ctx context.Context, inChan chan string, outChan chan uploadResult) {
	for {
		select {
		case <-ctx.Done():
			return
		case localPath := <-inChan:
			var file model.MynahFile
			err := mynahServer.UploadFile("upload", localPath, &file)
			outChan <- uploadResult{
				err:          err,
				fileid:       file.Uuid,
				originalPath: localPath,
			}
		}
	}
}

// get all upload paths
func enumerateFilePaths(folders []string) ([]string, error) {
	paths := make([]string, 0)
	for _, dirPath := range folders {
		if err := pathMustBeDir(dirPath); err != nil {
			return nil, fmt.Errorf("failed to upload files: %s", err)
		}

		//traverse this folder
		err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			} else if !info.IsDir() {
				paths = append(paths, path)
			}
			return nil
		})
		if err != nil {
			return nil, fmt.Errorf("error traversing directory: %s", err)
		}
	}
	return paths, nil
}

// ExecuteTask executes the upload task
func (t MynahUploadTask) ExecuteTask(mynahServer *server.MynahClient,
	_ MynahTaskContext) (context.Context, error) {

	filePaths, err := enumerateFilePaths(t.FolderPaths)
	if err != nil {
		return nil, err
	}

	inChan := make(chan string, len(filePaths))
	outChan := make(chan uploadResult, maxUploadWorkers)

	workerCount := maxUploadWorkers

	if !t.Multithread {
		workerCount = 1
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer func() {
		cancel()
		close(outChan)
	}()

	// start workers
	for i := 0; i < workerCount; i++ {
		go uploadWorker(mynahServer, ctx, inChan, outChan)
	}

	uploadedSet := make(UploadedFilesSet)

	progressBar := utils.NewCLITaskProgressBar("Upload", int64(len(filePaths)))

	// distribute to workers
	for _, path := range filePaths {
		inChan <- path
	}

	for i := 0; i < len(filePaths); i++ {
		uploadRes := <-outChan

		if uploadRes.err != nil {
			return nil, fmt.Errorf("failed to upload file %s: %s", uploadRes.originalPath, uploadRes.err)
		}

		progressBar.Increment()

		//create a mapping from the assigned fileid to the original path
		uploadedSet[uploadRes.fileid] = uploadRes.originalPath
	}

	progressBar.Complete()

	//add the file id map to the context generated by this task
	return context.WithValue(context.Background(), UploadedFilesSetKey, uploadedSet), nil
}

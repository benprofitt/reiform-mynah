// Copyright (c) 2022 by Reiform. All Rights Reserved.

package task

import (
	"context"
	"fmt"
	"net/http"
	"reiform.com/mynah-cli/server"
	"reiform.com/mynah-cli/utils"
	"reiform.com/mynah/model"
)

// UploadedFilesSet maps from fileid to the original
type UploadedFilesSet map[string]string

// UploadedFilesSetKey is the key for the upload result context
const UploadedFilesSetKey contextKey = "UploadedFilesSet"

// MynahUploadTask defines the task of uploading files to the server from some source
type MynahUploadTask struct {
	//the paths to the files to upload
	FilePaths []string `json:"file_paths"`
	//whether to use multiple threads
	Multithread bool `json:"multithread"`
}

//the result of performing an upload request
type uploadResult struct {
	err          error
	fileid       string
	originalPath string
}

// uploadAsForm creates a form, makes a post request, and returns the fileid on success
func uploadAsForm(mynahServer *server.MynahClient,
	localPath string) (string, error) {

	//create a multipart form
	formBuff, formContent, err := utils.CreateMultipartForm(localPath)
	if err != nil {
		return "", err
	}

	//add the form to a post request to the mynah server
	req, err := mynahServer.NewRequest("POST", "upload", &formBuff)
	if err != nil {
		return "", err
	}

	req.Header.Set("Content-Type", formContent)

	//make the request
	response, err := mynahServer.MakeRequest(req)
	if err != nil {
		return "", err
	}

	if response.StatusCode != http.StatusOK {
		return "", fmt.Errorf("upload failed with status: %s", response.Status)
	}

	//parse the response
	var file model.MynahFile

	if err = server.RequestParseJson(response, &file); err != nil {
		return "", err
	}

	return file.Uuid, nil
}

// executeUpload uploads a file
func executeUpload(mynahServer *server.MynahClient,
	localPath string,
	resChan chan uploadResult) {

	fileid, err := uploadAsForm(mynahServer, localPath)

	//write the result
	resChan <- uploadResult{
		err:          err,
		fileid:       fileid,
		originalPath: localPath,
	}
}

// ExecuteTask executes the upload task
func (t MynahUploadTask) ExecuteTask(mynahServer *server.MynahClient,
	_ MynahTaskContext) (context.Context, error) {

	resChan := make(chan uploadResult, len(t.FilePaths))

	for _, path := range t.FilePaths {
		if t.Multithread {
			go executeUpload(mynahServer, path, resChan)
		} else {
			executeUpload(mynahServer, path, resChan)
		}
	}

	uploadedSet := make(UploadedFilesSet)

	for i := 0; i < len(t.FilePaths); i++ {
		uploadRes := <-resChan

		if uploadRes.err != nil {
			return nil, fmt.Errorf("failed to upload file %s: %s", uploadRes.originalPath, uploadRes.err)
		}

		//create a mapping from the assigned fileid to the original path
		uploadedSet[uploadRes.fileid] = uploadRes.originalPath
	}

	//add the file id map to the context generated by this task
	return context.WithValue(context.Background(), UploadedFilesSetKey, uploadedSet), nil
}

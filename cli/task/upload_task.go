// Copyright (c) 2022 by Reiform. All Rights Reserved.

package task

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"reiform.com/mynah-cli/server"
	"reiform.com/mynah-cli/utils"
	"reiform.com/mynah/log"
	"reiform.com/mynah/model"
)

// UploadedFilesSet maps from fileid to the original
type UploadedFilesSet map[string]string

// UploadedFilesSetKey is the key for the upload result context
const UploadedFilesSetKey contextKey = "UploadedFilesSet"

// MynahUploadTask defines the task of uploading files to the server from some source
type MynahUploadTask struct {
	//the paths to folders to upload
	FolderPaths []string `json:"folder_paths"`
	//whether to use multiple threads
	Multithread bool `json:"multithread"`
}

//the result of performing an upload request
type uploadResult struct {
	err          error
	fileid       string
	originalPath string
}

// uploadAsForm creates a form, makes a post request, and returns the fileid on success
func uploadAsForm(mynahServer *server.MynahClient,
	localPath string) (string, error) {

	//create a multipart form
	formBuff, formContent, err := utils.CreateMultipartForm(localPath)
	if err != nil {
		return "", err
	}

	//add the form to a post request to the mynah server
	req, err := mynahServer.NewRequest("POST", "upload", &formBuff)
	if err != nil {
		return "", err
	}

	req.Header.Set("Content-Type", formContent)

	//make the request
	response, err := mynahServer.MakeRequest(req)
	if err != nil {
		return "", err
	}

	if response.StatusCode != http.StatusOK {
		return "", fmt.Errorf("upload failed with status: %s", response.Status)
	}

	//parse the response
	var file model.MynahFile

	if err = server.RequestParseJson(response, &file); err != nil {
		return "", err
	}

	return file.Uuid, nil
}

// executeUpload uploads a file
func executeUpload(mynahServer *server.MynahClient,
	localPath string,
	resChan chan uploadResult) {

	fileid, err := uploadAsForm(mynahServer, localPath)

	//write the result
	resChan <- uploadResult{
		err:          err,
		fileid:       fileid,
		originalPath: localPath,
	}
}

// returns error if this path is not to a folder
func pathMustBeDir(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}

	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			log.Warnf("failed to close file: %s", err)
		}
	}(file)

	//check that this is a folder
	if fileInfo, err := file.Stat(); err != nil {
		return err
	} else if !fileInfo.IsDir() {
		return fmt.Errorf("path %s is not a folder", path)
	}
	return nil
}

// ExecuteTask executes the upload task
func (t MynahUploadTask) ExecuteTask(mynahServer *server.MynahClient,
	_ MynahTaskContext) (context.Context, error) {

	resChan := make(chan uploadResult, len(t.FolderPaths))

	for _, dirPath := range t.FolderPaths {
		if err := pathMustBeDir(dirPath); err != nil {
			return nil, fmt.Errorf("failed to upload files: %s", err)
		}

		//traverse this folder
		err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			} else if !info.IsDir() {
				if t.Multithread {
					go executeUpload(mynahServer, path, resChan)
				} else {
					executeUpload(mynahServer, path, resChan)
				}
			}
			return nil
		})

		if err != nil {
			return nil, fmt.Errorf("failed to upload files: %s", err)
		}
	}

	uploadedSet := make(UploadedFilesSet)

	for i := 0; i < len(t.FolderPaths); i++ {
		uploadRes := <-resChan

		if uploadRes.err != nil {
			return nil, fmt.Errorf("failed to upload file %s: %s", uploadRes.originalPath, uploadRes.err)
		}

		//create a mapping from the assigned fileid to the original path
		uploadedSet[uploadRes.fileid] = uploadRes.originalPath
	}

	//add the file id map to the context generated by this task
	return context.WithValue(context.Background(), UploadedFilesSetKey, uploadedSet), nil
}
